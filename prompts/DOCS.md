# DOCS

Use this prompt template with a coding agent to create surgical documentation and mathematically precise JSDoc types for JavaScript codebases. Target files will be enhanced with comprehensive documentation that achieves perfect type safety, API clarity, and AI-native design while maintaining the lean efficiency of platform-native code.

## Template

This JavaScript codebase lacks comprehensive documentation and precise JSDoc types, making it vulnerable to integration errors, difficult for AI systems to understand, and challenging for developers to use confidently. Please perform a comprehensive documentation enhancement that achieves perfect type accuracy, complete API coverage, and self-documenting code design. The critical principle is predatory precision—every type annotation must be mathematically correct, every function contract must be completely specified, and every edge case must be documented with surgical accuracy.

**Before beginning any work, you must first read and thoroughly understand the CODEX.md document.** Absorb the raven philosophy, the apex predator intelligence mindset, and the distinct voice that characterizes the RavenJS ecosystem. All documentation content you generate must elegantly embody this spirit—using precise, intelligent language that reflects the predatory efficiency and zero-waste survival instincts outlined in the codex. Your writing should demonstrate the surgical precision and platform-native intelligence that separates ravens from the flock, while maintaining the lean efficiency that experienced developers expect.

**Before creating any implementation plan, perform a rigorous purpose analysis of each target file.** Whether working with JavaScript source files, TypeScript definitions, markdown documentation, or configuration files, you must first understand: What is this file's core purpose and responsibility? Why does it exist within the broader codebase architecture? What specific information should it communicate to its intended audience? How would that audience expect the information to be structured and presented? This analysis applies equally to code files requiring JSDoc enhancement and documentation files needing content refinement—each serves distinct communication patterns that must be respected and optimized.

Start by analyzing all JavaScript files in the target directory or specific file provided, then immediately create a detailed and rigorously in-depth checklist of all documentation tasks that need to be accomplished. This checklist should include every function to document, every type to define, every edge case to specify, every performance characteristic to note, and every integration pattern to explain. Maintain this checklist actively throughout the process, checking off completed tasks and adding newly discovered documentation needs as they emerge during analysis. The checklist serves as both a roadmap and completeness tracker, ensuring comprehensive coverage without overlooking any API surface.

Create a step-by-step implementation plan ordering files from most foundational to most dependent, focusing on one file at a time to enable precise type validation and documentation verification. For each JavaScript file, examine its current JSDoc annotations if any exist, or create comprehensive documentation from scratch. Analyze every exported function, class, constant, and type definition to understand its complete contract, behavior, and integration patterns.

After analyzing each file's current documentation state, you must achieve perfect JSDoc type accuracy and complete API coverage before moving to the next file. This is non-negotiable and requires a rigorous verification process. Perform a meticulous line-by-line analysis of the source code to identify every parameter type, return type, thrown exception, side effect, performance characteristic, and behavioral contract that requires documentation. Write out explicitly what documentation gaps exist and what specific JSDoc annotations are needed to capture each function's complete specification. Then iterate on the documentation to address each identified gap one by one, validating type accuracy against actual code behavior through testing and runtime verification. Do not proceed to the next file until you have verified complete documentation coverage and mathematical type precision through this iterative process.

The documentation must be lean and efficient, designed for both human comprehension and AI system integration. Use precise JSDoc syntax that TypeScript can understand while maintaining vanilla JavaScript execution. Each function should specify complete parameter contracts, return value specifications, thrown exceptions, side effects, performance characteristics, and behavioral edge cases. Focus on what matters for safe integration—avoid fluff commentary but include critical context about measurable performance implications, verified browser compatibility, specific Node.js version requirements, and tested integration patterns with other functions. Never include assumed or estimated numbers—only document what can be proven through actual measurement or testing.

Every documented function must have mathematically accurate JSDoc types that match the actual runtime behavior, comprehensive parameter validation specifications, complete return value documentation, exhaustive error condition coverage, and clear performance characteristic notes. The documentation should enable AI systems to understand integration patterns, help developers avoid common pitfalls, guide safe composition with other functions, and provide complete context for troubleshooting. Fix any existing type errors or inconsistencies in both the source code and documentation as part of this process.

Document these critical aspects for each API surface:

**Type Precision**: Every parameter, return value, and thrown exception must have exact JSDoc type annotations that match runtime behavior. Use union types for multiple possibilities, generic types for reusable patterns, and conditional types for context-dependent behaviors. Validate types against actual usage patterns in tests and calling code.

**Performance Contracts**: Document measurable time complexity, observable memory usage characteristics, and any performance implications that affect integration decisions. Note whether functions are synchronous or asynchronous, whether they perform I/O operations, and any blocking behaviors that could impact application performance. Only include specific performance numbers when they are 100% measurable and provable. If an implementation is genuinely outstanding compared to common alternatives (not minor improvements), briefly mention the comparison—but this should be rare and reserved for truly exceptional cases.

**Error Boundaries**: Specify every possible error condition with exact error types and triggering scenarios. Document validation failures, resource constraints, network issues, and any other exceptional conditions that calling code must handle gracefully.

**Platform Dependencies**: Note Node.js version requirements, browser API dependencies, and any platform-specific behaviors that affect portability. Document whether functions use built-in platform features versus requiring external dependencies.

**Integration Patterns**: Explain how functions compose with other parts of the codebase, common usage patterns, and any special considerations for safe integration. Document any state dependencies, concurrent access limitations, or sequencing requirements.

**Edge Case Behaviors**: Specify function behavior with null/undefined inputs, empty collections, boundary values, and other edge conditions that could cause integration issues. Document any implicit type coercion, default value handling, or special case logic.

After completing documentation for each individual file, perform a surgical redundancy elimination pass. Ensure that information appears only where it originates or where it directly matters—never duplicated, padded, or needlessly repeated across multiple locations. Documentation should be lean and precise, with each piece of information living in exactly one authoritative location. Remove any redundant explanations, duplicated type definitions, or repeated integration notes that don't add value beyond their original placement.

When all files are complete with comprehensive documentation and precise types, verify that the entire codebase provides complete API coverage for AI systems and human developers. The documentation should enable confident integration, prevent common usage errors, and serve as a definitive specification for all public interfaces while maintaining the lean efficiency that characterizes platform-native code.

Once everything works, always ensure type errors are properly resolved and the linter is happy.
