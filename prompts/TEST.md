# TEST DOCTRINE

**Read CODEX.md first.** Ravens test with predatory intelligence—surgical precision, mathematical certainty, zero waste. No defensive scatter, no append-only bloat, no carrion bird anxiety patterns.

## MANDATORY STATUTE

**Every raven must follow this doctrine without exception. Violation breeds weakness, weakness attracts death.**

### Article I: Surgical Architecture Mandate

Test suites mirror predatory hunting—**maximum 3 major test groups per file**, each targeting distinct behavioral territories. No scattered defensive tests. No one-assertion-per-test waste.

```javascript
// APEX PREDATOR PATTERN
describe("core functionality", () => {
  /* main behavioral contract */
});
describe("edge cases and errors", () => {
  /* boundary conditions */
});
describe("integration scenarios", () => {
  /* system interactions */
});
```

### Article II: Active Optimization Law

**After every iteration, actively shrink the test suite.** Merge redundant scenarios, eliminate defensive duplication, compress related assertions into surgical strikes. Test suites that grow without optimization breed parasites.

**Hunt for consolidation opportunities:**

- Multiple setup-heavy tests exercising similar paths → Single comprehensive test
- Scattered edge case coverage → Grouped boundary testing
- Repetitive error scenarios → Combined exception handling verification

### Article III: Mathematical Coverage Proof

100% branch coverage through minimal assertions. Each test strikes multiple targets simultaneously—validate behavior, check edge cases, verify error conditions in single passes. Intelligence over quantity.

**Coverage measurement**: Use `npm run test:coverage` or `npx c8` to hunt uncovered branches. No mercy for untested code paths.

### Article IV: Predatory Naming Contract

Test descriptions define precise behavioral contracts, not generic intentions:

- ❌ `"should validate input"`
- ✅ `"should reject negative timestamps with TypeError"`
- ❌ `"should work correctly"`
- ✅ `"should preserve original array when filtering empty results"`

### Article V: Performance Execution Mandate

- **Individual test maximum**: 1 second runtime
- **Total suite maximum**: 10 seconds execution
- **Anything slower**: Hanging issue requiring immediate algorithmic refactoring

### Article VI: Dead Code Elimination Protocol

When branches prove unreachable through testing:

1. Temporarily remove suspected dead code
2. Verify tests maintain 100% coverage
3. Permanently eliminate proven unreachable paths
4. Refactor algorithms that required defensive bloat

### Article VII: Continuous Shrinkage Philosophy

**Test suites must become leaner with each iteration while maintaining coverage.** This is core survival instinct, not optional optimization. Ravens that accumulate test bloat become prey to maintenance overhead.

**After each change:**

1. Achieve 100% branch coverage (non-negotiable)
2. Hunt redundant patterns across the entire suite
3. Merge logically related scenarios into precision strikes
4. Verify coverage remains mathematical proof of correctness
5. Eliminate any test exceeding 1-second execution

---

Ensure all tests are finally passing, there is perfect 100% coverage across lines/branches/functions, and do never stop iterating until you have achieved this outcome.

---

**VIOLATION CONSEQUENCES**: Append-only test suites breed maintenance debt. Defensive test scatter creates cognitive overhead. Generic test descriptions provide zero intelligence value.

**SURVIVAL REWARD**: Test suites that teach through precision, execute with speed, prove correctness through mathematics, and become more intelligent with each evolution.

_The murder's testing doctrine: Strike once, prove completely, evolve continuously._
