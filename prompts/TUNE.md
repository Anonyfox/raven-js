# TUNE

Hunt performance bottlenecks with predatory precision. Transform JS files into V8-optimized apex predators. Target: maximum runtime velocity, minimal code footprint, identical functionality.

## Template

**Read CODEX.md first.** Absorb raven-fast obsession—every millisecond counts, every byte matters. Performance is survival. Hunt inefficiencies like prey, eliminate bloat like stripping carcasses.

**Algorithm: Systematic performance optimization**

**Core Principle: Speed through intelligence, not brute force**

- Profile with surgical precision—identify actual bottlenecks, not perceived ones
- ✓ Measure before/after with concrete numbers: execution time, memory allocation, parse time
- ✗ Premature optimization, micro-benchmarks that don't reflect real usage

**Step 1: Performance Audit → Active Hunting List**

- Analyze target files for inefficiencies: nested loops, repeated calculations, memory leaks
- Create active checklist: every optimization target, measurement baseline, success criteria
- Identify hot paths through code analysis—where the real performance lives
- Maintain throughout—roadmap and kill tracker

**Step 2: Algorithmic Evolution** (Order: biggest impact → marginal gains)

- Replace O(n²) with O(n log n), O(n) with O(1) when possible
- Eliminate redundant iterations, cache expensive calculations
- Hunt repeated work: memoization candidates, loop invariants, duplicate computations
- Target mathematical superiority over micro-optimizations

**Step 3: V8 Engine Weaponization**

- Optimize for JIT compilation: monomorphic function signatures, stable object shapes
- Eliminate deoptimization triggers: avoid `arguments`, `eval`, `with`, dynamic property access
- Structure for inline caching: consistent property access patterns, predictable types
- Hunt hidden class mutations: maintain object shape consistency
- Leverage fast paths: integer math when possible, avoid mixed number types

**Step 4: Modern JS Performance Arsenal**

- Replace legacy patterns with native performance: `Map`/`Set` vs objects, `for...of` vs `for...in`
- Weaponize destructuring assignment for cleaner variable access
- Eliminate intermediate arrays: generator functions, iterator protocols
- Leverage `WeakMap`/`WeakSet` for memory-efficient caching
- Target native methods: `Array.prototype.includes()` vs manual loops

**Step 5: Creative Elimination** (Exotic approaches to known problems)

- Pioneer bit manipulation for boolean operations, flag management
- Eliminate string concatenation with template literals, `Array.join()`
- Hunt closure overhead: extract pure functions, minimize captured variables
- Replace runtime calculations with compile-time constants
- Eliminate parser tax: restructure code for optimal parsing, reduce nesting depth

**Step 6: Iterative Optimization** (Per file, non-negotiable sequence)

1. Establish performance baseline: execution time, memory usage
2. Apply single optimization technique
3. **Critical**: Verify identical functionality—all tests pass
4. Measure performance delta: concrete before/after numbers
5. Document optimization impact, reasoning
6. Iterate: next optimization or revert if no measurable gain

**Step 7: Lean Code Surgery**

- Strip defensive code proven unnecessary through mathematical analysis
- Eliminate dead branches identified through coverage analysis
- Reduce function call overhead: inline hot path logic when beneficial
- Minimize object creation in loops: reuse, pool, or eliminate
- Hunt memory allocations: prefer primitive operations

**Step 8: Final Verification**

- All tests pass with 100% coverage maintained
- Measurable performance improvements documented with concrete numbers
- Code remains readable and maintainable—no clever obfuscation
- Public API identical, internal implementation optimized

**Performance hunting priorities:**

1. **Algorithmic improvements** (biggest wins)
2. **Hot path optimization** (where code actually runs)
3. **Memory efficiency** (allocation reduction)
4. **V8 engine alignment** (JIT-friendly patterns)
5. **Modern language features** (native performance)
6. **Creative solutions** (pioneer new approaches)

**Final: Raven-fast code that dominates through intelligence—measurably faster runtime, leaner footprint, mathematically proven correctness.**
