# PERFORMANCE DOCTRINE

**Read CODEX.md first.** Ravens achieve speed through elimination, not optimization. The apex performance weapon is code that never runs—eliminate branches, functions, entire algorithms before optimizing survivors.

## MANDATORY STATUTE

**Every raven must follow this doctrine without exception. Optimization without elimination breeds performance theater that wastes territorial resources.**

### Article I: Minimization-First Law

**Code elimination beats code optimization.** The fastest JavaScript is JavaScript that never executes. Remove unnecessary branches, functions, entire algorithms before applying surgical optimizations to survivors.

**Elimination hierarchy:**

1. **Delete entire functions** that prove unnecessary through usage analysis
2. **Remove conditional branches** that mathematical analysis proves unreachable
3. **Eliminate redundant calculations** performed multiple times
4. **Strip defensive code** that tests prove unnecessary
5. **Merge duplicate logic** scattered across multiple locations

### Article II: Measurement Discipline

**Every optimization must prove measurable dominance.** Ravens demand concrete before/after numbers with ruthless elimination of insignificant gains and regressions.

**Required measurement standards:**

- **Baseline establishment**: Execution time, memory allocation, parse time
- **Delta verification**: Concrete percentage improvements documented
- **Gain threshold**: <5% improvements get eliminated immediately as noise
- **Regression elimination**: Any performance decrease triggers immediate revert
- **Real-world benchmarks**: Measure actual usage patterns, not synthetic micro-tests

### Article III: Lean-First Optimization Sequence

**Minimize code before optimizing code.** Apply optimization techniques only to lean survivors that passed elimination protocols.

## STEP-BY-STEP EXECUTION PROTOCOL

**Step 1: Elimination Analysis → Surgical Removal**

- Identify elimination targets: unused functions, unreachable branches, duplicate logic
- Create active kill list: every elimination candidate with removal impact assessment
- Document baseline metrics: current code size, execution paths, performance characteristics
- Execute elimination surgery: remove entire code sections before optimizing survivors

**Step 2: Algorithmic Minimization** (Order: biggest elimination → marginal removal)

- Replace complex algorithms with simpler approaches that achieve identical results
- Hunt redundant iterations: eliminate loops that recalculate known values
- Remove repeated work: identify calculations performed multiple times unnecessarily
- Target mathematical simplification over micro-optimization complexity

**Step 3: Measurement-Driven Optimization** (Per change, non-negotiable sequence)

1. **Establish baseline**: Measure current performance with concrete numbers
2. **Apply single technique**: One optimization approach per iteration
3. **Verify functionality**: All tests pass with identical behavior
4. **Measure delta**: Document exact performance change percentage
5. **Elimination decision**: <5% gain → revert immediately, >5% gain → document and continue
6. **Iterate**: Next optimization or move to next function

**Step 4: V8 Engine Weaponization** (Only for lean survivors)

- Optimize for JIT compilation: monomorphic function signatures, stable object shapes
- Eliminate deoptimization triggers: avoid `arguments`, `eval`, `with`, dynamic property access
- Structure for inline caching: consistent property access patterns, predictable types
- Hunt hidden class mutations: maintain object shape consistency
- Leverage fast paths: integer math, avoid mixed number types

**Step 5: Modern JS Performance Arsenal** (Platform-native speed)

- Replace legacy patterns with native performance: `Map`/`Set` vs objects, `for...of` vs `for...in`
- Weaponize destructuring for cleaner variable access
- Eliminate intermediate arrays: generator functions, iterator protocols
- Leverage `WeakMap`/`WeakSet` for memory-efficient caching
- Target native methods: `Array.prototype.includes()` vs manual loops

**Step 6: Creative Elimination Techniques** (Exotic minimization approaches)

- Pioneer bit manipulation for boolean operations, flag management
- Eliminate string concatenation with template literals, `Array.join()`
- Hunt closure overhead: extract pure functions, minimize captured variables
- Replace runtime calculations with compile-time constants
- Eliminate parser tax: restructure for optimal parsing, reduce nesting depth

**Step 7: Lean Code Surgery** (Final elimination pass)

- Strip defensive code proven unnecessary through mathematical analysis
- Remove dead branches identified through coverage analysis
- Reduce function call overhead: inline hot path logic when measurements prove beneficial
- Minimize object creation in loops: reuse, pool, or eliminate entirely
- Hunt memory allocations: prefer primitive operations

**Step 8: Performance Verification Protocol**

- **Functionality proof**: All tests pass with 100% coverage maintained
- **Performance evidence**: Measurable improvements documented with concrete percentages
- **Regression elimination**: Any <5% gain or performance decrease reverted immediately
- **Maintainability preservation**: Code remains readable—no clever obfuscation
- **API guarantee**: Public interface identical, internal implementation optimized

**Performance hunting priorities (Elimination → Optimization):**

1. **Code elimination** (fastest code never runs)
2. **Algorithmic minimization** (simplest approach that works)
3. **Measurement discipline** (prove every change with numbers)
4. **Hot path optimization** (optimize what actually executes)
5. **V8 engine alignment** (JIT-friendly patterns)
6. **Modern language features** (platform-native performance)

---

**VIOLATION CONSEQUENCES**: Optimization without elimination wastes resources on unnecessary complexity. Unmeasured performance changes accumulate noise and regressions. <5% gains create maintenance overhead without velocity benefits.

**SURVIVAL REWARD**: Code that achieves maximum velocity through minimum complexity, with every optimization mathematically proven to provide measurable territorial advantages.

_The murder's performance doctrine: Eliminate first, optimize survivors, measure everything, prove dominance._
